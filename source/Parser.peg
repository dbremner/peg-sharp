# Grammar for peg files as a peg file...# If this is changed the usage doc should be updated as well.exclude-exception = truestart = PegFileused = IncludedFilevalue = Expressiondebug = noneAction := '`' [^`]+ '`';Any := '.' S `value = new RangeExpression("\x0001-\xFFFF")`AssertExpression := '&' PostfixExpression `value = new AssertExpression(results[1].Value)`AssertExpression := '!' PostfixExpression `value = new NAssertExpression(results[1].Value)`AssertExpression := PostfixExpression;Comment := '#' [^\n\r]* S `;` `expected = "comment"`Expression := SequenceExpression ('/' S SequenceExpression)* `value = DoChoice(results)`Identifier := [a-zA-Z_]+ ([+-] [a-zA-Z_0-9]+)+ S `;` `expected = "identifier"`Identifier := [a-zA-Z_] [a-zA-Z_0-9]* S `;` `expected = "identifier"`Include := 'include' S Path `m_includes.Add(results[1].Text.Trim())` `expected = "include"`IncludedFile := S Comment* (Include / Rule / Comment)+;Integer := [0-9]+ S `;` `expected = "integer"`Literal := '\'' ('\\\'' / '\x5c\x5c' / [^'])+ '\'' S `string literal = text.Trim(); value = new LiteralExpression(literal.Substring(1, literal.Length - 2))` `expected = "literal"`Literal := '"' ('\\"' / '\x5c\x5c' / [^"])+ '"' S `string literal = text.Trim(); value = new LiteralExpression(literal.Substring(1, literal.Length - 2))` `expected = "literal"`Path := PathComponent ('/' PathComponent)* ('.' PathName)* S 		`;` `expected = "path"`PathComponent := '..';PathComponent := '.';PathComponent := PathName;PathName := [a-zA-Z0-9_-]+;PegFile := S (Setting / Comment)+ (Include / Rule / RuleEpilogFail / RuleEpilogPass / RuleEpilog / RuleProlog / Comment)+;PostfixExpression := PrimitiveExpression '{' S Integer ',' S Integer '}' S `value = DoRepetition(results[0].Value, int.Parse(results[2].Text), int.Parse(results[4].Text), results[0].Index)`PostfixExpression := PrimitiveExpression '{' S Integer ',' S '}' S `value = DoRepetition(results[0].Value, int.Parse(results[2].Text), int.MaxValue, results[0].Index)`PostfixExpression := PrimitiveExpression '*' S `value = DoRepetition(results[0].Value, 0, int.MaxValue, results[0].Index)`PostfixExpression := PrimitiveExpression '+' S `value = DoRepetition(results[0].Value, 1, int.MaxValue, results[0].Index)`PostfixExpression := PrimitiveExpression '?' S `value = DoRepetition(results[0].Value, 0, 1, results[0].Index)`PostfixExpression := PrimitiveExpression;PrimitiveExpression := Any / Literal / Range / SubRule / SubExpression;Range := '[' ('\\]' / '\\\\' / [^\]])+ ']' S `fatal = DoRange(text, ref value)` `expected = "range literal"`Rule := Identifier ':=' S Expression (';' / Action S Action?) S `DoAddRule(results)` `expected = "rule"`RuleEpilog := Identifier ':>' S Action S `m_grammar.AddHook(Hook.Epilog, results[0].Text.Trim(), results[2].Text.Trim())` `expected = "rule epilog"`RuleEpilogFail := Identifier ':>!=' S Action S `m_grammar.AddHook(Hook.FailEpilog, results[0].Text.Trim(), results[2].Text.Trim())` `expected = "rule epilog"`RuleEpilogPass := Identifier ':>=' S Action S `m_grammar.AddHook(Hook.PassEpilog, results[0].Text.Trim(), results[2].Text.Trim())` `expected = "rule epilog"`RuleProlog := Identifier ':<' S Action S `m_grammar.AddHook(Hook.Prolog, results[0].Text.Trim(), results[2].Text.Trim())` `expected = "rule prolog"`S := Space* `text = null`SequenceExpression := AssertExpression+ `value = DoSequence(results)`Setting := Identifier '=' S Value S 	`fatal = DoAddSetting(results)` `expected = "setting"`Space := [ \t\r\n] `;` `expected = "whitespace"`SubExpression := '(' S Expression ')' S `value = results[1].Value` `expected = "parenthesized expression"`SubRule := Identifier `value = new RuleExpression(text.Trim())` `expected = "rule name"`Value := [^\t\n\r]+;