// Machine generated by peg-sharp 0.4.898.0 from source/Parser.peg.
using System;
using System.Collections.Generic;
using System.Globalization;
using System.Runtime.Serialization;
using System.Security.Permissions;

// Thread safe if Parser instances are not shared across threads.
internal sealed partial class Parser
{
	public Parser()
	{
		m_nonterminals.Add("Action", new ParseMethod[]{this.DoParseActionRule});
		m_nonterminals.Add("Any", new ParseMethod[]{this.DoParseAnyRule});
		m_nonterminals.Add("AssertExpression", new ParseMethod[]{this.DoParseAssertExpression1Rule, this.DoParseAssertExpression2Rule, this.DoParseAssertExpression3Rule});
		m_nonterminals.Add("Comment", new ParseMethod[]{this.DoParseCommentRule});
		m_nonterminals.Add("Expression", new ParseMethod[]{this.DoParseExpressionRule});
		m_nonterminals.Add("Identifier", new ParseMethod[]{this.DoParseIdentifier1Rule, this.DoParseIdentifier2Rule});
		m_nonterminals.Add("Include", new ParseMethod[]{this.DoParseIncludeRule});
		m_nonterminals.Add("IncludedFile", new ParseMethod[]{this.DoParseIncludedFileRule});
		m_nonterminals.Add("Integer", new ParseMethod[]{this.DoParseIntegerRule});
		m_nonterminals.Add("Literal", new ParseMethod[]{this.DoParseLiteral1Rule, this.DoParseLiteral2Rule});
		m_nonterminals.Add("Path", new ParseMethod[]{this.DoParsePathRule});
		m_nonterminals.Add("PathComponent", new ParseMethod[]{this.DoParsePathComponent1Rule, this.DoParsePathComponent2Rule, this.DoParsePathComponent3Rule});
		m_nonterminals.Add("PathName", new ParseMethod[]{this.DoParsePathNameRule});
		m_nonterminals.Add("PegFile", new ParseMethod[]{this.DoParsePegFileRule});
		m_nonterminals.Add("PostfixExpression", new ParseMethod[]{this.DoParsePostfixExpression1Rule, this.DoParsePostfixExpression2Rule, this.DoParsePostfixExpression3Rule, this.DoParsePostfixExpression4Rule, this.DoParsePostfixExpression5Rule, this.DoParsePostfixExpression6Rule});
		m_nonterminals.Add("PrimitiveExpression", new ParseMethod[]{this.DoParsePrimitiveExpressionRule});
		m_nonterminals.Add("Range", new ParseMethod[]{this.DoParseRangeRule});
		m_nonterminals.Add("Rule", new ParseMethod[]{this.DoParseRuleRule});
		m_nonterminals.Add("RuleEpilog", new ParseMethod[]{this.DoParseRuleEpilogRule});
		m_nonterminals.Add("RuleEpilogFail", new ParseMethod[]{this.DoParseRuleEpilogFailRule});
		m_nonterminals.Add("RuleEpilogPass", new ParseMethod[]{this.DoParseRuleEpilogPassRule});
		m_nonterminals.Add("RuleProlog", new ParseMethod[]{this.DoParseRulePrologRule});
		m_nonterminals.Add("S", new ParseMethod[]{this.DoParseSRule});
		m_nonterminals.Add("SequenceExpression", new ParseMethod[]{this.DoParseSequenceExpressionRule});
		m_nonterminals.Add("Setting", new ParseMethod[]{this.DoParseSettingRule});
		m_nonterminals.Add("Space", new ParseMethod[]{this.DoParseSpaceRule});
		m_nonterminals.Add("SubExpression", new ParseMethod[]{this.DoParseSubExpressionRule});
		m_nonterminals.Add("SubRule", new ParseMethod[]{this.DoParseSubRuleRule});
		m_nonterminals.Add("Value", new ParseMethod[]{this.DoParseValueRule});
		OnCtorEpilog();
	}
	
	public Expression Parse(string input)
	{
		return DoParseFile(input, null, "PegFile");
	}
	
	// File is used for error reporting.
	public Expression Parse(string input, string file)
	{
		return DoParseFile(input, file, "PegFile");
	}
	
	#region Non-Terminal Parse Methods
	// Action := '`' [^`]+ '`'
	private State DoParseActionRule(State _state, List<Result> _outResults)
	{
		State _start = _state;
		List<Result> results = new List<Result>();
		
		_state = DoSequence(_state, results,
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, "`");},
			delegate (State s, List<Result> r) {return DoRepetition(s, r, 1, 2147483647,
				delegate (State s2, List<Result> r2) {return DoParseRange(s2, r2, true, "`", string.Empty, null, "[^`]");});},
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, "`");});
		
		if (_state.Parsed)
		{
			Expression value = results.Count > 0 ? results[0].Value : default(Expression);
			_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
		}
		
		return _state;
	}
	
	// Any := '.' S
	private State DoParseAnyRule(State _state, List<Result> _outResults)
	{
		State _start = _state;
		List<Result> results = new List<Result>();
		
		_state = DoSequence(_state, results,
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, ".");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "S");});
		
		if (_state.Parsed)
		{
			Expression value = results.Count > 0 ? results[0].Value : default(Expression);
			value = new RangeExpression("\x0001-\xFFFF");
			_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
		}
		
		return _state;
	}
	
	// AssertExpression := '&' PostfixExpression
	private State DoParseAssertExpression1Rule(State _state, List<Result> _outResults)
	{
		State _start = _state;
		List<Result> results = new List<Result>();
		
		_state = DoSequence(_state, results,
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, "&");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "PostfixExpression");});
		
		if (_state.Parsed)
		{
			Expression value = results.Count > 0 ? results[0].Value : default(Expression);
			value = new AssertExpression(results[1].Value);
			_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
		}
		
		return _state;
	}
	
	// AssertExpression := '!' PostfixExpression
	private State DoParseAssertExpression2Rule(State _state, List<Result> _outResults)
	{
		State _start = _state;
		List<Result> results = new List<Result>();
		
		_state = DoSequence(_state, results,
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, "!");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "PostfixExpression");});
		
		if (_state.Parsed)
		{
			Expression value = results.Count > 0 ? results[0].Value : default(Expression);
			value = new NAssertExpression(results[1].Value);
			_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
		}
		
		return _state;
	}
	
	// AssertExpression := PostfixExpression
	private State DoParseAssertExpression3Rule(State _state, List<Result> _outResults)
	{
		State _start = _state;
		List<Result> results = new List<Result>();
		
		_state = DoParse(_state, results, "PostfixExpression");
		
		if (_state.Parsed)
		{
			Expression value = results.Count > 0 ? results[0].Value : default(Expression);
			_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
		}
		
		return _state;
	}
	
	// Comment := '#' [^\n\r]* S
	private State DoParseCommentRule(State _state, List<Result> _outResults)
	{
		State _start = _state;
		List<Result> results = new List<Result>();
		
		_state = DoSequence(_state, results,
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, "#");},
			delegate (State s, List<Result> r) {return DoRepetition(s, r, 0, 2147483647,
				delegate (State s2, List<Result> r2) {return DoParseRange(s2, r2, true, "\n\r", string.Empty, null, "[^\n\r]");});},
			delegate (State s, List<Result> r) {return DoParse(s, r, "S");});
		
		if (_state.Parsed)
		{
			Expression value = results.Count > 0 ? results[0].Value : default(Expression);
			_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
		}
		else
		{
			string expected = null;
			expected = "comment";
			if (expected != null)
				_state = new State(_start.Index, false, ErrorSet.Combine(_start.Errors, new ErrorSet(_state.Errors.Index, expected)));
		}
		
		return _state;
	}
	
	// Expression := SequenceExpression ('/' S SequenceExpression)*
	private State DoParseExpressionRule(State _state, List<Result> _outResults)
	{
		State _start = _state;
		List<Result> results = new List<Result>();
		
		_state = DoSequence(_state, results,
			delegate (State s, List<Result> r) {return DoParse(s, r, "SequenceExpression");},
			delegate (State s, List<Result> r) {return DoRepetition(s, r, 0, 2147483647,
				delegate (State s2, List<Result> r2) {return DoSequence(s2, r2,
					delegate (State s3, List<Result> r3) {return DoParseLiteral(s3, r3, "/");},
					delegate (State s3, List<Result> r3) {return DoParse(s3, r3, "S");},
					delegate (State s3, List<Result> r3) {return DoParse(s3, r3, "SequenceExpression");});});});
		
		if (_state.Parsed)
		{
			Expression value = results.Count > 0 ? results[0].Value : default(Expression);
			value = DoChoice(results);
			_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
		}
		
		return _state;
	}
	
	// Identifier := [_a-zA-Z]+ ([+-] [_a-zA-Z0-9]+)+ S
	private State DoParseIdentifier1Rule(State _state, List<Result> _outResults)
	{
		State _start = _state;
		List<Result> results = new List<Result>();
		
		_state = DoSequence(_state, results,
			delegate (State s, List<Result> r) {return DoRepetition(s, r, 1, 2147483647,
				delegate (State s2, List<Result> r2) {return DoParseRange(s2, r2, false, "_", "azAZ", null, "[_a-zA-Z]");});},
			delegate (State s, List<Result> r) {return DoRepetition(s, r, 1, 2147483647,
				delegate (State s2, List<Result> r2) {return DoSequence(s2, r2,
					delegate (State s3, List<Result> r3) {return DoParseRange(s3, r3, false, "+-", string.Empty, null, "[+-]");},
					delegate (State s3, List<Result> r3) {return DoRepetition(s3, r3, 1, 2147483647,
						delegate (State s4, List<Result> r4) {return DoParseRange(s4, r4, false, "_", "azAZ09", null, "[_a-zA-Z0-9]");});});});},
			delegate (State s, List<Result> r) {return DoParse(s, r, "S");});
		
		if (_state.Parsed)
		{
			Expression value = results.Count > 0 ? results[0].Value : default(Expression);
			_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
		}
		else
		{
			string expected = null;
			expected = "identifier";
			if (expected != null)
				_state = new State(_start.Index, false, ErrorSet.Combine(_start.Errors, new ErrorSet(_state.Errors.Index, expected)));
		}
		
		return _state;
	}
	
	// Identifier := [_a-zA-Z] [_a-zA-Z0-9]* S
	private State DoParseIdentifier2Rule(State _state, List<Result> _outResults)
	{
		State _start = _state;
		List<Result> results = new List<Result>();
		
		_state = DoSequence(_state, results,
			delegate (State s, List<Result> r) {return DoParseRange(s, r, false, "_", "azAZ", null, "[_a-zA-Z]");},
			delegate (State s, List<Result> r) {return DoRepetition(s, r, 0, 2147483647,
				delegate (State s2, List<Result> r2) {return DoParseRange(s2, r2, false, "_", "azAZ09", null, "[_a-zA-Z0-9]");});},
			delegate (State s, List<Result> r) {return DoParse(s, r, "S");});
		
		if (_state.Parsed)
		{
			Expression value = results.Count > 0 ? results[0].Value : default(Expression);
			_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
		}
		else
		{
			string expected = null;
			expected = "identifier";
			if (expected != null)
				_state = new State(_start.Index, false, ErrorSet.Combine(_start.Errors, new ErrorSet(_state.Errors.Index, expected)));
		}
		
		return _state;
	}
	
	// Include := 'include' S Path
	private State DoParseIncludeRule(State _state, List<Result> _outResults)
	{
		State _start = _state;
		List<Result> results = new List<Result>();
		
		_state = DoSequence(_state, results,
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, "include");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "S");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "Path");});
		
		if (_state.Parsed)
		{
			Expression value = results.Count > 0 ? results[0].Value : default(Expression);
			m_includes.Add(results[1].Text.Trim());
			_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
		}
		else
		{
			string expected = null;
			expected = "include";
			if (expected != null)
				_state = new State(_start.Index, false, ErrorSet.Combine(_start.Errors, new ErrorSet(_state.Errors.Index, expected)));
		}
		
		return _state;
	}
	
	// IncludedFile := S Comment* (Include / Rule / Comment)+
	private State DoParseIncludedFileRule(State _state, List<Result> _outResults)
	{
		State _start = _state;
		List<Result> results = new List<Result>();
		
		_state = DoSequence(_state, results,
			delegate (State s, List<Result> r) {return DoParse(s, r, "S");},
			delegate (State s, List<Result> r) {return DoRepetition(s, r, 0, 2147483647,
				delegate (State s2, List<Result> r2) {return DoParse(s2, r2, "Comment");});},
			delegate (State s, List<Result> r) {return DoRepetition(s, r, 1, 2147483647,
				delegate (State s2, List<Result> r2) {return DoChoice(s2, r2,
					delegate (State s3, List<Result> r3) {return DoParse(s3, r3, "Include");},
					delegate (State s3, List<Result> r3) {return DoParse(s3, r3, "Rule");},
					delegate (State s3, List<Result> r3) {return DoParse(s3, r3, "Comment");});});});
		
		if (_state.Parsed)
		{
			Expression value = results.Count > 0 ? results[0].Value : default(Expression);
			_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
		}
		
		return _state;
	}
	
	// Integer := [0-9]+ S
	private State DoParseIntegerRule(State _state, List<Result> _outResults)
	{
		State _start = _state;
		List<Result> results = new List<Result>();
		
		_state = DoSequence(_state, results,
			delegate (State s, List<Result> r) {return DoRepetition(s, r, 1, 2147483647,
				delegate (State s2, List<Result> r2) {return DoParseRange(s2, r2, false, string.Empty, "09", null, "[0-9]");});},
			delegate (State s, List<Result> r) {return DoParse(s, r, "S");});
		
		if (_state.Parsed)
		{
			Expression value = results.Count > 0 ? results[0].Value : default(Expression);
			_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
		}
		else
		{
			string expected = null;
			expected = "integer";
			if (expected != null)
				_state = new State(_start.Index, false, ErrorSet.Combine(_start.Errors, new ErrorSet(_state.Errors.Index, expected)));
		}
		
		return _state;
	}
	
	// Literal := '\'' ('\\\'' / '\x5c\x5c' / [^'])+ '\'' S
	private State DoParseLiteral1Rule(State _state, List<Result> _outResults)
	{
		State _start = _state;
		List<Result> results = new List<Result>();
		
		_state = DoSequence(_state, results,
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, "\'");},
			delegate (State s, List<Result> r) {return DoRepetition(s, r, 1, 2147483647,
				delegate (State s2, List<Result> r2) {return DoChoice(s2, r2,
					delegate (State s3, List<Result> r3) {return DoParseLiteral(s3, r3, "\\\'");},
					delegate (State s3, List<Result> r3) {return DoParseLiteral(s3, r3, "\x5c\x5c");},
					delegate (State s3, List<Result> r3) {return DoParseRange(s3, r3, true, "'", string.Empty, null, "[^']");});});},
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, "\'");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "S");});
		
		if (_state.Parsed)
		{
			Expression value = results.Count > 0 ? results[0].Value : default(Expression);
			string text = m_input.Substring(_start.Index, _state.Index - _start.Index);
			string literal = text.Trim(); value = new LiteralExpression(literal.Substring(1, literal.Length - 2));
			if (text != null)
				_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
		}
		else
		{
			string expected = null;
			expected = "literal";
			if (expected != null)
				_state = new State(_start.Index, false, ErrorSet.Combine(_start.Errors, new ErrorSet(_state.Errors.Index, expected)));
		}
		
		return _state;
	}
	
	// Literal := '"' ('\\"' / '\x5c\x5c' / [^\"])+ '"' S
	private State DoParseLiteral2Rule(State _state, List<Result> _outResults)
	{
		State _start = _state;
		List<Result> results = new List<Result>();
		
		_state = DoSequence(_state, results,
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, "\"");},
			delegate (State s, List<Result> r) {return DoRepetition(s, r, 1, 2147483647,
				delegate (State s2, List<Result> r2) {return DoChoice(s2, r2,
					delegate (State s3, List<Result> r3) {return DoParseLiteral(s3, r3, "\\\"");},
					delegate (State s3, List<Result> r3) {return DoParseLiteral(s3, r3, "\x5c\x5c");},
					delegate (State s3, List<Result> r3) {return DoParseRange(s3, r3, true, "\"", string.Empty, null, "[^\"]");});});},
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, "\"");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "S");});
		
		if (_state.Parsed)
		{
			Expression value = results.Count > 0 ? results[0].Value : default(Expression);
			string text = m_input.Substring(_start.Index, _state.Index - _start.Index);
			string literal = text.Trim(); value = new LiteralExpression(literal.Substring(1, literal.Length - 2));
			if (text != null)
				_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
		}
		else
		{
			string expected = null;
			expected = "literal";
			if (expected != null)
				_state = new State(_start.Index, false, ErrorSet.Combine(_start.Errors, new ErrorSet(_state.Errors.Index, expected)));
		}
		
		return _state;
	}
	
	// Path := PathComponent ('/' PathComponent)* ('.' PathName)* S
	private State DoParsePathRule(State _state, List<Result> _outResults)
	{
		State _start = _state;
		List<Result> results = new List<Result>();
		
		_state = DoSequence(_state, results,
			delegate (State s, List<Result> r) {return DoParse(s, r, "PathComponent");},
			delegate (State s, List<Result> r) {return DoRepetition(s, r, 0, 2147483647,
				delegate (State s2, List<Result> r2) {return DoSequence(s2, r2,
					delegate (State s3, List<Result> r3) {return DoParseLiteral(s3, r3, "/");},
					delegate (State s3, List<Result> r3) {return DoParse(s3, r3, "PathComponent");});});},
			delegate (State s, List<Result> r) {return DoRepetition(s, r, 0, 2147483647,
				delegate (State s2, List<Result> r2) {return DoSequence(s2, r2,
					delegate (State s3, List<Result> r3) {return DoParseLiteral(s3, r3, ".");},
					delegate (State s3, List<Result> r3) {return DoParse(s3, r3, "PathName");});});},
			delegate (State s, List<Result> r) {return DoParse(s, r, "S");});
		
		if (_state.Parsed)
		{
			Expression value = results.Count > 0 ? results[0].Value : default(Expression);
			_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
		}
		else
		{
			string expected = null;
			expected = "path";
			if (expected != null)
				_state = new State(_start.Index, false, ErrorSet.Combine(_start.Errors, new ErrorSet(_state.Errors.Index, expected)));
		}
		
		return _state;
	}
	
	// PathComponent := '..'
	private State DoParsePathComponent1Rule(State _state, List<Result> _outResults)
	{
		State _start = _state;
		List<Result> results = new List<Result>();
		
		_state = DoParseLiteral(_state, results, "..");
		
		if (_state.Parsed)
		{
			Expression value = results.Count > 0 ? results[0].Value : default(Expression);
			_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
		}
		
		return _state;
	}
	
	// PathComponent := '.'
	private State DoParsePathComponent2Rule(State _state, List<Result> _outResults)
	{
		State _start = _state;
		List<Result> results = new List<Result>();
		
		_state = DoParseLiteral(_state, results, ".");
		
		if (_state.Parsed)
		{
			Expression value = results.Count > 0 ? results[0].Value : default(Expression);
			_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
		}
		
		return _state;
	}
	
	// PathComponent := PathName
	private State DoParsePathComponent3Rule(State _state, List<Result> _outResults)
	{
		State _start = _state;
		List<Result> results = new List<Result>();
		
		_state = DoParse(_state, results, "PathName");
		
		if (_state.Parsed)
		{
			Expression value = results.Count > 0 ? results[0].Value : default(Expression);
			_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
		}
		
		return _state;
	}
	
	// PathName := [_-a-zA-Z0-9]+
	private State DoParsePathNameRule(State _state, List<Result> _outResults)
	{
		State _start = _state;
		List<Result> results = new List<Result>();
		
		_state = DoRepetition(_state, results, 1, 2147483647,
			delegate (State s, List<Result> r) {return DoParseRange(s, r, false, "_-", "azAZ09", null, "[_-a-zA-Z0-9]");});
		
		if (_state.Parsed)
		{
			Expression value = results.Count > 0 ? results[0].Value : default(Expression);
			_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
		}
		
		return _state;
	}
	
	// PegFile := S (Setting / Comment)+ (Include / Rule / RuleEpilogFail / RuleEpilogPass / RuleEpilog / RuleProlog / Comment)+
	private State DoParsePegFileRule(State _state, List<Result> _outResults)
	{
		State _start = _state;
		List<Result> results = new List<Result>();
		
		_state = DoSequence(_state, results,
			delegate (State s, List<Result> r) {return DoParse(s, r, "S");},
			delegate (State s, List<Result> r) {return DoRepetition(s, r, 1, 2147483647,
				delegate (State s2, List<Result> r2) {return DoChoice(s2, r2,
					delegate (State s3, List<Result> r3) {return DoParse(s3, r3, "Setting");},
					delegate (State s3, List<Result> r3) {return DoParse(s3, r3, "Comment");});});},
			delegate (State s, List<Result> r) {return DoRepetition(s, r, 1, 2147483647,
				delegate (State s2, List<Result> r2) {return DoChoice(s2, r2,
					delegate (State s3, List<Result> r3) {return DoParse(s3, r3, "Include");},
					delegate (State s3, List<Result> r3) {return DoParse(s3, r3, "Rule");},
					delegate (State s3, List<Result> r3) {return DoParse(s3, r3, "RuleEpilogFail");},
					delegate (State s3, List<Result> r3) {return DoParse(s3, r3, "RuleEpilogPass");},
					delegate (State s3, List<Result> r3) {return DoParse(s3, r3, "RuleEpilog");},
					delegate (State s3, List<Result> r3) {return DoParse(s3, r3, "RuleProlog");},
					delegate (State s3, List<Result> r3) {return DoParse(s3, r3, "Comment");});});});
		
		if (_state.Parsed)
		{
			Expression value = results.Count > 0 ? results[0].Value : default(Expression);
			_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
		}
		
		return _state;
	}
	
	// PostfixExpression := PrimitiveExpression '{' S Integer ',' S Integer '}' S
	private State DoParsePostfixExpression1Rule(State _state, List<Result> _outResults)
	{
		State _start = _state;
		List<Result> results = new List<Result>();
		
		_state = DoSequence(_state, results,
			delegate (State s, List<Result> r) {return DoParse(s, r, "PrimitiveExpression");},
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, "{");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "S");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "Integer");},
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, ",");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "S");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "Integer");},
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, "}");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "S");});
		
		if (_state.Parsed)
		{
			Expression value = results.Count > 0 ? results[0].Value : default(Expression);
			value = DoRepetition(results[0].Value, int.Parse(results[2].Text), int.Parse(results[4].Text), results[0].Index);
			_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
		}
		
		return _state;
	}
	
	// PostfixExpression := PrimitiveExpression '{' S Integer ',' S '}' S
	private State DoParsePostfixExpression2Rule(State _state, List<Result> _outResults)
	{
		State _start = _state;
		List<Result> results = new List<Result>();
		
		_state = DoSequence(_state, results,
			delegate (State s, List<Result> r) {return DoParse(s, r, "PrimitiveExpression");},
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, "{");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "S");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "Integer");},
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, ",");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "S");},
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, "}");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "S");});
		
		if (_state.Parsed)
		{
			Expression value = results.Count > 0 ? results[0].Value : default(Expression);
			value = DoRepetition(results[0].Value, int.Parse(results[2].Text), int.MaxValue, results[0].Index);
			_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
		}
		
		return _state;
	}
	
	// PostfixExpression := PrimitiveExpression '*' S
	private State DoParsePostfixExpression3Rule(State _state, List<Result> _outResults)
	{
		State _start = _state;
		List<Result> results = new List<Result>();
		
		_state = DoSequence(_state, results,
			delegate (State s, List<Result> r) {return DoParse(s, r, "PrimitiveExpression");},
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, "*");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "S");});
		
		if (_state.Parsed)
		{
			Expression value = results.Count > 0 ? results[0].Value : default(Expression);
			value = DoRepetition(results[0].Value, 0, int.MaxValue, results[0].Index);
			_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
		}
		
		return _state;
	}
	
	// PostfixExpression := PrimitiveExpression '+' S
	private State DoParsePostfixExpression4Rule(State _state, List<Result> _outResults)
	{
		State _start = _state;
		List<Result> results = new List<Result>();
		
		_state = DoSequence(_state, results,
			delegate (State s, List<Result> r) {return DoParse(s, r, "PrimitiveExpression");},
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, "+");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "S");});
		
		if (_state.Parsed)
		{
			Expression value = results.Count > 0 ? results[0].Value : default(Expression);
			value = DoRepetition(results[0].Value, 1, int.MaxValue, results[0].Index);
			_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
		}
		
		return _state;
	}
	
	// PostfixExpression := PrimitiveExpression '?' S
	private State DoParsePostfixExpression5Rule(State _state, List<Result> _outResults)
	{
		State _start = _state;
		List<Result> results = new List<Result>();
		
		_state = DoSequence(_state, results,
			delegate (State s, List<Result> r) {return DoParse(s, r, "PrimitiveExpression");},
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, "?");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "S");});
		
		if (_state.Parsed)
		{
			Expression value = results.Count > 0 ? results[0].Value : default(Expression);
			value = DoRepetition(results[0].Value, 0, 1, results[0].Index);
			_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
		}
		
		return _state;
	}
	
	// PostfixExpression := PrimitiveExpression
	private State DoParsePostfixExpression6Rule(State _state, List<Result> _outResults)
	{
		State _start = _state;
		List<Result> results = new List<Result>();
		
		_state = DoParse(_state, results, "PrimitiveExpression");
		
		if (_state.Parsed)
		{
			Expression value = results.Count > 0 ? results[0].Value : default(Expression);
			_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
		}
		
		return _state;
	}
	
	// PrimitiveExpression := Any / Literal / Range / SubRule / SubExpression
	private State DoParsePrimitiveExpressionRule(State _state, List<Result> _outResults)
	{
		State _start = _state;
		List<Result> results = new List<Result>();
		
		_state = DoChoice(_state, results,
			delegate (State s, List<Result> r) {return DoParse(s, r, "Any");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "Literal");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "Range");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "SubRule");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "SubExpression");});
		
		if (_state.Parsed)
		{
			Expression value = results.Count > 0 ? results[0].Value : default(Expression);
			_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
		}
		
		return _state;
	}
	
	// Range := '[' ('\\]' / '\\\\' / [^\\]])+ ']' S
	private State DoParseRangeRule(State _state, List<Result> _outResults)
	{
		State _start = _state;
		List<Result> results = new List<Result>();
		
		_state = DoSequence(_state, results,
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, "[");},
			delegate (State s, List<Result> r) {return DoRepetition(s, r, 1, 2147483647,
				delegate (State s2, List<Result> r2) {return DoChoice(s2, r2,
					delegate (State s3, List<Result> r3) {return DoParseLiteral(s3, r3, "\\]");},
					delegate (State s3, List<Result> r3) {return DoParseLiteral(s3, r3, "\\\\");},
					delegate (State s3, List<Result> r3) {return DoParseRange(s3, r3, true, "]", string.Empty, null, "[^\\]]");});});},
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, "]");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "S");});
		
		if (_state.Parsed)
		{
			Expression value = results.Count > 0 ? results[0].Value : default(Expression);
			string fatal = null;
			string text = m_input.Substring(_start.Index, _state.Index - _start.Index);
			fatal = DoRange(text, ref value);
			if (!string.IsNullOrEmpty(fatal))
				DoThrow(_start.Index, fatal);
			if (text != null)
				_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
		}
		else
		{
			string expected = null;
			expected = "range literal";
			if (expected != null)
				_state = new State(_start.Index, false, ErrorSet.Combine(_start.Errors, new ErrorSet(_state.Errors.Index, expected)));
		}
		
		return _state;
	}
	
	// Rule := Identifier ':=' S Expression (';' / (Action S Action?)) S
	private State DoParseRuleRule(State _state, List<Result> _outResults)
	{
		State _start = _state;
		List<Result> results = new List<Result>();
		
		_state = DoSequence(_state, results,
			delegate (State s, List<Result> r) {return DoParse(s, r, "Identifier");},
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, ":=");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "S");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "Expression");},
			delegate (State s, List<Result> r) {return DoChoice(s, r,
				delegate (State s2, List<Result> r2) {return DoParseLiteral(s2, r2, ";");},
				delegate (State s2, List<Result> r2) {return DoSequence(s2, r2,
					delegate (State s3, List<Result> r3) {return DoParse(s3, r3, "Action");},
					delegate (State s3, List<Result> r3) {return DoParse(s3, r3, "S");},
					delegate (State s3, List<Result> r3) {return DoRepetition(s3, r3, 0, 1,
						delegate (State s4, List<Result> r4) {return DoParse(s4, r4, "Action");});});});},
			delegate (State s, List<Result> r) {return DoParse(s, r, "S");});
		
		if (_state.Parsed)
		{
			Expression value = results.Count > 0 ? results[0].Value : default(Expression);
			DoAddRule(results);
			_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
		}
		else
		{
			string expected = null;
			expected = "rule";
			if (expected != null)
				_state = new State(_start.Index, false, ErrorSet.Combine(_start.Errors, new ErrorSet(_state.Errors.Index, expected)));
		}
		
		return _state;
	}
	
	// RuleEpilog := Identifier ':>' S Action S
	private State DoParseRuleEpilogRule(State _state, List<Result> _outResults)
	{
		State _start = _state;
		List<Result> results = new List<Result>();
		
		_state = DoSequence(_state, results,
			delegate (State s, List<Result> r) {return DoParse(s, r, "Identifier");},
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, ":>");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "S");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "Action");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "S");});
		
		if (_state.Parsed)
		{
			Expression value = results.Count > 0 ? results[0].Value : default(Expression);
			m_grammar.AddHook(Hook.Epilog, results[0].Text.Trim(), results[2].Text.Trim());
			_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
		}
		else
		{
			string expected = null;
			expected = "rule epilog";
			if (expected != null)
				_state = new State(_start.Index, false, ErrorSet.Combine(_start.Errors, new ErrorSet(_state.Errors.Index, expected)));
		}
		
		return _state;
	}
	
	// RuleEpilogFail := Identifier ':>!=' S Action S
	private State DoParseRuleEpilogFailRule(State _state, List<Result> _outResults)
	{
		State _start = _state;
		List<Result> results = new List<Result>();
		
		_state = DoSequence(_state, results,
			delegate (State s, List<Result> r) {return DoParse(s, r, "Identifier");},
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, ":>!=");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "S");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "Action");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "S");});
		
		if (_state.Parsed)
		{
			Expression value = results.Count > 0 ? results[0].Value : default(Expression);
			m_grammar.AddHook(Hook.FailEpilog, results[0].Text.Trim(), results[2].Text.Trim());
			_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
		}
		else
		{
			string expected = null;
			expected = "rule epilog";
			if (expected != null)
				_state = new State(_start.Index, false, ErrorSet.Combine(_start.Errors, new ErrorSet(_state.Errors.Index, expected)));
		}
		
		return _state;
	}
	
	// RuleEpilogPass := Identifier ':>=' S Action S
	private State DoParseRuleEpilogPassRule(State _state, List<Result> _outResults)
	{
		State _start = _state;
		List<Result> results = new List<Result>();
		
		_state = DoSequence(_state, results,
			delegate (State s, List<Result> r) {return DoParse(s, r, "Identifier");},
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, ":>=");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "S");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "Action");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "S");});
		
		if (_state.Parsed)
		{
			Expression value = results.Count > 0 ? results[0].Value : default(Expression);
			m_grammar.AddHook(Hook.PassEpilog, results[0].Text.Trim(), results[2].Text.Trim());
			_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
		}
		else
		{
			string expected = null;
			expected = "rule epilog";
			if (expected != null)
				_state = new State(_start.Index, false, ErrorSet.Combine(_start.Errors, new ErrorSet(_state.Errors.Index, expected)));
		}
		
		return _state;
	}
	
	// RuleProlog := Identifier ':<' S Action S
	private State DoParseRulePrologRule(State _state, List<Result> _outResults)
	{
		State _start = _state;
		List<Result> results = new List<Result>();
		
		_state = DoSequence(_state, results,
			delegate (State s, List<Result> r) {return DoParse(s, r, "Identifier");},
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, ":<");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "S");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "Action");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "S");});
		
		if (_state.Parsed)
		{
			Expression value = results.Count > 0 ? results[0].Value : default(Expression);
			m_grammar.AddHook(Hook.Prolog, results[0].Text.Trim(), results[2].Text.Trim());
			_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
		}
		else
		{
			string expected = null;
			expected = "rule prolog";
			if (expected != null)
				_state = new State(_start.Index, false, ErrorSet.Combine(_start.Errors, new ErrorSet(_state.Errors.Index, expected)));
		}
		
		return _state;
	}
	
	// S := Space*
	private State DoParseSRule(State _state, List<Result> _outResults)
	{
		State _start = _state;
		List<Result> results = new List<Result>();
		
		_state = DoRepetition(_state, results, 0, 2147483647,
			delegate (State s, List<Result> r) {return DoParse(s, r, "Space");});
		
		if (_state.Parsed)
		{
			Expression value = results.Count > 0 ? results[0].Value : default(Expression);
			string text = m_input.Substring(_start.Index, _state.Index - _start.Index);
			text = null;
			if (text != null)
				_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
		}
		
		return _state;
	}
	
	// SequenceExpression := AssertExpression+
	private State DoParseSequenceExpressionRule(State _state, List<Result> _outResults)
	{
		State _start = _state;
		List<Result> results = new List<Result>();
		
		_state = DoRepetition(_state, results, 1, 2147483647,
			delegate (State s, List<Result> r) {return DoParse(s, r, "AssertExpression");});
		
		if (_state.Parsed)
		{
			Expression value = results.Count > 0 ? results[0].Value : default(Expression);
			value = DoSequence(results);
			_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
		}
		
		return _state;
	}
	
	// Setting := Identifier '=' S Value S
	private State DoParseSettingRule(State _state, List<Result> _outResults)
	{
		State _start = _state;
		List<Result> results = new List<Result>();
		
		_state = DoSequence(_state, results,
			delegate (State s, List<Result> r) {return DoParse(s, r, "Identifier");},
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, "=");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "S");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "Value");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "S");});
		
		if (_state.Parsed)
		{
			Expression value = results.Count > 0 ? results[0].Value : default(Expression);
			string fatal = null;
			fatal = DoAddSetting(results);
			if (!string.IsNullOrEmpty(fatal))
				DoThrow(_start.Index, fatal);
			_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
		}
		else
		{
			string expected = null;
			expected = "setting";
			if (expected != null)
				_state = new State(_start.Index, false, ErrorSet.Combine(_start.Errors, new ErrorSet(_state.Errors.Index, expected)));
		}
		
		return _state;
	}
	
	// Space := [ \t\r\n]
	private State DoParseSpaceRule(State _state, List<Result> _outResults)
	{
		State _start = _state;
		List<Result> results = new List<Result>();
		
		_state = DoParseRange(_state, results, false, " \t\r\n", string.Empty, null, "[ \t\r\n]");
		
		if (_state.Parsed)
		{
			Expression value = results.Count > 0 ? results[0].Value : default(Expression);
			_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
		}
		else
		{
			string expected = null;
			expected = "whitespace";
			if (expected != null)
				_state = new State(_start.Index, false, ErrorSet.Combine(_start.Errors, new ErrorSet(_state.Errors.Index, expected)));
		}
		
		return _state;
	}
	
	// SubExpression := '(' S Expression ')' S
	private State DoParseSubExpressionRule(State _state, List<Result> _outResults)
	{
		State _start = _state;
		List<Result> results = new List<Result>();
		
		_state = DoSequence(_state, results,
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, "(");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "S");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "Expression");},
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, ")");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "S");});
		
		if (_state.Parsed)
		{
			Expression value = results.Count > 0 ? results[0].Value : default(Expression);
			value = results[1].Value;
			_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
		}
		else
		{
			string expected = null;
			expected = "parenthesized expression";
			if (expected != null)
				_state = new State(_start.Index, false, ErrorSet.Combine(_start.Errors, new ErrorSet(_state.Errors.Index, expected)));
		}
		
		return _state;
	}
	
	// SubRule := Identifier
	private State DoParseSubRuleRule(State _state, List<Result> _outResults)
	{
		State _start = _state;
		List<Result> results = new List<Result>();
		
		_state = DoParse(_state, results, "Identifier");
		
		if (_state.Parsed)
		{
			Expression value = results.Count > 0 ? results[0].Value : default(Expression);
			string text = m_input.Substring(_start.Index, _state.Index - _start.Index);
			value = new RuleExpression(text.Trim());
			if (text != null)
				_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
		}
		else
		{
			string expected = null;
			expected = "rule name";
			if (expected != null)
				_state = new State(_start.Index, false, ErrorSet.Combine(_start.Errors, new ErrorSet(_state.Errors.Index, expected)));
		}
		
		return _state;
	}
	
	// Value := [^\t\n\r]+
	private State DoParseValueRule(State _state, List<Result> _outResults)
	{
		State _start = _state;
		List<Result> results = new List<Result>();
		
		_state = DoRepetition(_state, results, 1, 2147483647,
			delegate (State s, List<Result> r) {return DoParseRange(s, r, true, "\t\n\r", string.Empty, null, "[^\t\n\r]");});
		
		if (_state.Parsed)
		{
			Expression value = results.Count > 0 ? results[0].Value : default(Expression);
			_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
		}
		
		return _state;
	}
	#endregion
	
	#region Private Helper Methods
	partial void OnCtorEpilog();
	partial void OnParseProlog();
	partial void OnParseEpilog(State state);
	
	private Expression DoParseFile(string input, string file, string rule)
	{
		m_file = file;
		m_input = m_file;				// we need to ensure that m_file is used or we will (in some cases) get a compiler warning
		m_input = input + "\x0";	// add a sentinel so we can avoid range checks
		m_cache.Clear();
		m_lineStarts = null;
		
		State state = new State(0, true);
		List<Result> results = new List<Result>();
		
		OnParseProlog();
		state = DoParse(state, results, rule);
		
		int i = state.Index;
		if (!state.Parsed)
			DoThrow(state.Errors.Index, state.Errors.ToString());
		else if (i < input.Length)
			if (state.Errors.Expected.Length > 0)
				DoThrow(state.Errors.Index, state.Errors.ToString());
			else
				DoThrow(state.Errors.Index, "Not all input was consumed starting from '" + input.Substring(i, Math.Min(16, input.Length - i)) + "'");
		OnParseEpilog(state);
		
		return results[0].Value;
	}
	
	public string DoEscapeAll(string s)
	{
		System.Text.StringBuilder builder = new System.Text.StringBuilder(s.Length);
		
		foreach (char ch in s)
		{
			if (ch == '\n')
				builder.Append("\\n");
			
			else if (ch == '\r')
				builder.Append("\\r");
			
			else if (ch == '\t')
				builder.Append("\\t");
			
			else if (ch < ' ')
				builder.AppendFormat("\\x{0:X2}", (int) ch);
			
			else
				builder.Append(ch);
		}
		
		return builder.ToString();
	}
	
	// This is most often used just for error handling where it is a bit overkill.
	// However it's also sometimes used in rule prologs where efficiency is more
	// important (and doing a bit of extra work in the error case is not very harmful).
	private int DoGetLine(int index)
	{
		if (m_lineStarts == null)
			DoBuildLineStarts();
			
		int line = m_lineStarts.BinarySearch(index);
		if (line >= 0)
			return line + 1;
			
		return ~line;
	}
	
	private void DoBuildLineStarts()
	{
		m_lineStarts = new List<int>();
		
		m_lineStarts.Add(0);		// line 1 starts at index 0 (even if we have no text)
		
		int i = 0;
		while (i < m_input.Length)
		{
			char ch = m_input[i++];
			
			if (ch == '\r' && m_input[i] == '\n')
			{
				m_lineStarts.Add(++i);
			}
			else if (ch == '\r')
			{
				m_lineStarts.Add(i);
			}
			else if (ch == '\n')
			{
				m_lineStarts.Add(i);
			}
		}
	}
	
	private int DoGetCol(int index)
	{
		int start = index;
		
		while (index > 0 && m_input[index - 1] != '\n' && m_input[index - 1] != '\r')
		{
			--index;
		}
		
		return start - index;
	}
	
	private void DoThrow(int index, string format, params object[] args)
	{
		int line = DoGetLine(index);
		int col = DoGetCol(index) + 1;	// editors seem to usually use 1-based cols so that's what we will report
	
		// We need this retarded if or string.Format will throw an error if it
		// gets a format string like "Expected { or something".
		if (args != null && args.Length > 0)
			throw new ParserException(line, col, index, m_file, m_input, DoEscapeAll(string.Format(format, args)));
		else
			throw new ParserException(line, col, index, m_file, m_input, DoEscapeAll(format));
	}
	
	private State DoParseLiteral(State state, List<Result> results, string literal)
	{
		State result;
		
		if (string.Compare(m_input, state.Index, literal, 0, literal.Length) == 0)
		{
			results.Add(new Result(this, state.Index, literal.Length, m_input, default(Expression)));
			result = new State(state.Index + literal.Length, true, state.Errors);
		}
		else
		{
			result = new State(state.Index, false, ErrorSet.Combine(state.Errors, new ErrorSet(state.Index, literal)));
		}
		
		return result;
	}
	
	private State DoParse(State state, List<Result> results, string nonterminal)
	{
		State start = state;
		
		CacheValue cache;
		CacheKey key = new CacheKey(nonterminal, start.Index, m_context);
		if (!m_cache.TryGetValue(key, out cache))
		{
			ParseMethod[] methods = m_nonterminals[nonterminal];
			
			int oldCount = results.Count;
			state = DoChoice(state, results, methods);
			
			bool hasResult = state.Parsed && results.Count > oldCount;
			Expression value = hasResult ? results[results.Count - 1].Value : default(Expression);
			cache = new CacheValue(state, value, hasResult);
			m_cache.Add(key, cache);
		}
		else
		{
			if (cache.HasResult)
				results.Add(new Result(this, start.Index, cache.State.Index - start.Index, m_input, cache.Value));
		}
		
		return cache.State;
	}
	
	private State DoChoice(State state, List<Result> results, params ParseMethod[] methods)
	{
		State start = state;
		int startResult = results.Count;
		
		foreach (ParseMethod method in methods)
		{
			State temp = method(state, results);
			if (temp.Parsed)
			{
				state = temp;
				break;
			}
			else
			{
				state = new State(start.Index, false, ErrorSet.Combine(state.Errors, temp.Errors));
				results.RemoveRange(startResult, results.Count - startResult);
			}
		}
		
		return state;
	}
	
	private State DoSequence(State state, List<Result> results, params ParseMethod[] methods)
	{
		State start = state;
		int startResult = results.Count;
		
		foreach (ParseMethod method in methods)
		{
			State temp = method(state, results);
			if (temp.Parsed)
			{
				state = temp;
			}
			else
			{
				state = new State(start.Index, false, ErrorSet.Combine(start.Errors, temp.Errors));
				results.RemoveRange(startResult, results.Count - startResult);
				break;
			}
		}
		
		return state;
	}
	
	private State DoRepetition(State state, List<Result> results, int min, int max, ParseMethod method)
	{
		State start = state;
		
		int count = 0;
		while (count <= max)
		{
			State temp = method(state, results);
			if (temp.Parsed && temp.Index > state.Index)
			{
				state = temp;
				++count;
			}
			else
			{
				state = new State(state.Index, true, ErrorSet.Combine(state.Errors, temp.Errors));
				break;
			}
		}
		
		if (count < min || count > max)
			state = new State(start.Index, false, ErrorSet.Combine(start.Errors, state.Errors));
		
		return state;
	}
	
	private State DoParseRange(State state, List<Result> results, bool inverted, string chars, string ranges, UnicodeCategory[] categories, string label)
	{
		char ch = m_input[state.Index];
		
		bool matched = chars.IndexOf(ch) >= 0;
		for (int i = 0; i < ranges.Length && !matched; i += 2)
		{
			matched = ranges[i] <= ch && ch <= ranges[i + 1];
		}
		for (int i = 0; categories != null && i < categories.Length && !matched; ++i)
		{
			matched = char.GetUnicodeCategory(ch) == categories[i];
		}
		
		if (inverted)
			matched = !matched && ch != '\x0';
		
		if (matched)
		{
			results.Add(new Result(this, state.Index, 1, m_input, default(Expression)));
			return new State(state.Index + 1, true, state.Errors);
		}
		
		return new State(state.Index, false, ErrorSet.Combine(state.Errors, new ErrorSet(state.Index, label)));
	}
	#endregion
	
	#region Private Types
	private struct CacheKey : IEquatable<CacheKey>
	{
		public CacheKey(string rule, int index, object context)
		{
			m_rule = rule;
			m_index = index;
			m_context = context;
		}
		
		public override bool Equals(object obj)
		{
			if (obj == null)
				return false;
			
			if (GetType() != obj.GetType())
				return false;
			
			CacheKey rhs = (CacheKey) obj;
			return this == rhs;
		}
		
		public bool Equals(CacheKey rhs)
		{
			return this == rhs;
		}
		
		public static bool operator==(CacheKey lhs, CacheKey rhs)
		{
			if (lhs.m_rule != rhs.m_rule)
				return false;
			
			if (lhs.m_index != rhs.m_index)
				return false;
			
			if (lhs.m_context != rhs.m_context)
				return false;
			
			return true;
		}
		
		public static bool operator!=(CacheKey lhs, CacheKey rhs)
		{
			return !(lhs == rhs);
		}
		
		public override int GetHashCode()
		{
			int hash = 0;
			
			unchecked
			{
				hash += m_rule.GetHashCode();
				hash += m_index.GetHashCode();
				hash += m_context.GetHashCode();
			}
			
			return hash;
		}
		
		private string m_rule;
		private int m_index;
		private object m_context;
	}
	
	private struct CacheValue
	{
		public CacheValue(State state, Expression value, bool hasResult)
		{
			State = state;
			Value = value;
			HasResult = hasResult;
		}
		
		public State State;
		
		public Expression Value;
		
		public bool HasResult;
	}
	
	private delegate State ParseMethod(State state, List<Result> results);
	
	// These are either an error that caused parsing to fail or the reason a
	// successful parse stopped.
	private struct ErrorSet
	{
		public ErrorSet(int index, string expected)
		{
			Index = index;
			Expected = new string[]{expected};
		}
		
		public ErrorSet(int index, string[] expected)
		{
			Index = index;
			Expected = expected;
		}
		
		// The location associated with the errors. For a failed parse this will be the
		// same as State.Index. For a successful parse it will be State.Index or later.
		public int Index;
		
		// This will be the name of something which was expected, but not found.
		public string[] Expected;
		
		public static ErrorSet Combine(ErrorSet lhs, ErrorSet rhs)
		{
			if (lhs.Index > rhs.Index)
			{
				return lhs;
			}
			else if (lhs.Index < rhs.Index)
			{
				return rhs;
			}
			else
			{
				List<string> errors = new List<string>(lhs.Expected.Length + rhs.Expected.Length);
				errors.AddRange(lhs.Expected);
				foreach (string err in rhs.Expected)
				{
					if (errors.IndexOf(err) < 0)
						errors.Add(err);
				}
				return new ErrorSet(lhs.Index, errors.ToArray());
			}
		}
		
		public override string ToString()
		{
			if (Expected.Length > 0)
				return string.Format("Expected {0}", string.Join(" or ", Expected));
			else
				return "<none>";
		}
	}
	
	// The state of the parser.
	private struct State
	{
		public State(int index, bool parsed)
		{
			Index = index;
			Parsed = parsed;
			Errors = new ErrorSet(index, new string[0]);
		}
		
		public State(int index, bool parsed, ErrorSet errors)
		{
			Index = index;
			Parsed = parsed;
			Errors = errors;
		}
		
		// Index of the first unconsumed character.
		public int Index;
		
		// True if the expression associated with the state successfully parsed.
		public bool Parsed;
		
		// If Parsed is false then this will explain why. If Parsed is true it will
		// say why the parse stopped.
		public ErrorSet Errors;
	}
	
	// The result of parsing a literal or non-terminal.
	private struct Result
	{
		public Result(Parser parser, int index, int length, string input, Expression value)
		{
			m_parser = parser;
			m_index = index;
			m_length = length;
			m_input = input;
			Value = value;
		}
		
		// The text which was parsed by the terminal or non-terminal.
		public string Text {get {return m_input.Substring(m_index, m_length);}}
		
		// The 0-based character index the (non)terminal started on.
		public int Index {get {return m_index;}}
		
		// The 1-based line number the (non)terminal started on.
		public int Line {get {return m_parser.DoGetLine(m_index);}}
		
		// The 1-based column number the (non)terminal started on.
		public int Col {get {return m_parser.DoGetCol(m_index);}}
		
		// For non-terminals this will be the result of the semantic action, 
		// otherwise it will be the default value.
		public Expression Value;
		
		private Parser m_parser;
		private int m_index;
		private int m_length;
		private string m_input;
	}
	
	#endregion
	
	#region Fields
	private string m_input;
	private string m_file;
	private object m_context = 0;
	private Dictionary<string, ParseMethod[]> m_nonterminals = new Dictionary<string, ParseMethod[]>();
	private Dictionary<CacheKey, CacheValue> m_cache = new Dictionary<CacheKey, CacheValue>();
	private List<int> m_lineStarts;	// offsets at which each line starts
	#endregion
}
