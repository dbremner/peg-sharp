# Grammar for peg files as a peg file...# If this is changed the usage doc should be updated as well.start = PegFilevalue = Expressiondebug =Action := '`' [^`]+ '`';Any := '.' S `value = new RangeExpression("\x0001-\xFFFF")`AssertExpression := '&' PostfixExpression `value = new AssertExpression(results[1].Value)`AssertExpression := '!' PostfixExpression `value = new NAssertExpression(results[1].Value)`AssertExpression := PostfixExpression;Comment := '#' [^\n\r]* S `;` `expected = "comment"`Expression := SequenceExpression ('/' S SequenceExpression)* `value = DoChoice(results)`Identifier := [a-zA-Z] [a-zA-Z0-9_-]* S `;` `expected = "identifier"`Integer := [0-9]+ S `;` `expected = "integer"` Literal := '\'' ('\\\'' / '\x5c\x5c' / [^'])+ '\'' S `string literal = text.Trim(); value = new LiteralExpression(literal.Substring(1, literal.Length - 2))` `expected = "literal"`Literal := '"' ('\\"' / '\x5c\x5c' / [^"])+ '"' S `string literal = text.Trim(); value = new LiteralExpression(literal.Substring(1, literal.Length - 2))` `expected = "literal"`PegFile := S (Setting / Comment)+ (Rule / Comment)+;PostfixExpression := PrimitiveExpression '{' S Integer ',' S Integer '}' S `value = new RepetitionExpression(results[0].Value, int.Parse(results[2].Text), int.Parse(results[4].Text))`PostfixExpression := PrimitiveExpression '{' S Integer ',' S '}' S `value = new RepetitionExpression(results[0].Value, int.Parse(results[2].Text), int.MaxValue)`PostfixExpression := PrimitiveExpression '*' S `value = new RepetitionExpression(results[0].Value, 0, int.MaxValue)`PostfixExpression := PrimitiveExpression '+' S `value = new RepetitionExpression(results[0].Value, 1, int.MaxValue)`PostfixExpression := PrimitiveExpression '?' S `value = new RepetitionExpression(results[0].Value, 0, 1)`PostfixExpression := PrimitiveExpression;PrimitiveExpression := Any / Literal / Range / SubRule / SubExpression;Range := '[' ('\\]' / '\\\\' / [^\]])+ ']' S `fatal = DoRange(text, ref value)` `expected = "range literal"`Rule := Identifier ':=' S Expression (';' / Action S Action?) S `DoAddRule(results)`S := Space* `text = null`SequenceExpression := AssertExpression+ `value = DoSequence(results)`Setting := Identifier '=' [ ]* ('\n' / '\r' / '\t') S `fatal = DoAddSetting(results[0].Text.Trim(), string.Empty)` `expected = "setting"`Setting := Identifier '=' S Value ('\n' / '\r' / '\t') S `fatal = DoAddSetting(results)` `expected = "setting"`Space := [ \t\r\n] `;` `expected = "whitespace"`SubExpression := '(' S Expression ')' S `value = results[1].Value` `expected = "parenthesized expression"`SubRule := Identifier `value = new RuleExpression(text.Trim())` `expected = "rule name"`Value := [^\t\n\r]+;