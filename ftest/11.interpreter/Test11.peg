# Grammar for a simple expression oriented language where all# the values are integers.start = Programvalue = Expressionignore-case = truecomment = The start of a commentcomment = // and the end.debug = false# ProgramProgram := S Statements;# "Statements"Assignment := Identifier '=' S Expression `value = new AssignmentExpression(results[0].Text.Trim(), results[2].Value)`If := 'if' S Expression 'then' S Statements 'else' S Statements 'end' S `value = new IfExpression(results[1].Value, results[3].Value, results[5].Value)`Statement := If / While / Assignment / Expression;Statements := Statement+ `value = new SequenceExpression(from r in results where r.Value != null select r.Value)`While := 'while' S Expression 'do' S Statements 'end' S `value = new WhileExpression(results[1].Value, results[3].Value)`# ExpressionsCompare := Sum (('<=' / '>=' / '==' / '!=' / '<' / '>') S Sum)? `if (results.Count > 1) value = DoCreateBinary(results)`Expression := Compare;Identifier := !Keywords [a-zA-Z] [a-zA-Z0-9]* S `value = new VariableExpression(text.Trim())` `expected = "variable"`Sum := Product (('+' / '-') S Product)*  `value = DoCreateBinary(results)`Product := Value (('*' / '/') S Value)*  `value = DoCreateBinary(results)`Value := [0-9]+ S `	int n;	if (!int.TryParse(text.Trim(), out n))		fatal = "Value is oor";	value = new LiteralExpression(n)` `expected = "number"`Value := Identifier;Value := '(' Expression ')' S `value = results[1].Value` `expected = "parenthesized expression"`# ScaffoldingKeywords := ('do' / 'else' / 'end' / 'if' / 'then' / 'while') ![a-zA-Z0-9];S := Space* `text = null`  # We use a separate space rule because x* always succeeds.Space := [ \t\r\n] `;` `expected = "whitespace"`