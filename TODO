http://pdos.csail.mit.edu/~baford/packrat/http://www.codeproject.com/KB/recipes/grammar_support_1.aspxhttp://www.replicator.org/node/67http://www.codeplex.com/ironyhttp://www.eqatec.com/tools/profilerhttp://code.google.com/p/nprof/ms (but team version)http://www.wikihow.com/Optimize-Your-Program%27s-Performancehttp://stackoverflow.com/questions/375913/what-can-i-use-to-profile-c-code-in-linux/378024#378024http://www.thinkingparallel.com/2007/04/18/ten-questions-with-joe-duffy-about-parallel-programming-and-net-threads/internal abstract class Expression	internal sealed class IfExpression	internal sealed class WhileExpression	internal sealed class AssignmentExpression	internal sealed class BinaryExpression	internal sealed class FloatExpression	internal sealed class IntegerExpression	internal sealed class VariableExpression	internal sealed class AssertExpression	internal sealed class ChoiceExpression	internal sealed class LiteralExpression	internal sealed class NAssertExpression	internal sealed class RangeExpression	internal sealed class RepetitionExpression	internal sealed class RuleExpression	internal sealed class SequenceExpression1) simplify the grammar2) figure out which nonterminals should be memoized and which should be simple functions3) generate the parser (look into the two-level trick)* Do a commit.* Get a test case suitable to use for benchmarking* Get a base line* Optimization pass:	- keep applying the rules until the grammar size doesn't change	- print the size of the grammar before and after optimizes	- inline tiny non-terminals (those that have no more than two operators), and have no actions	- inline non-terminals that are referenced only once, and have no actions	- special case multiple instances of repetition opertors applied to the same subrule	- optimize nested sequence expressions, s1/s2/(s3/s4)/s5	- optimize nested choice expressions, s1|s2|(s3|s4)|s5	- optimize sequence expressions with one element	- optimize choice expressions with one alternative	- detect alternatives of literals where some literals have a common prefix	- use a switch after refactoring literals alternatives* Work on optimization:	- do some profiling	- could inline simple rules (eg Space) before they are written	- could get rid of helpers like DoSequence	- look into using pointers to avoid string [] range checks	- [...] / [...]* May want to update the peg-sharp used by coco.* Look into optionally generating c++ code.* Do a release.* Should there be an explicit way to match eot?* Might be nice to add some support for error recovery so multiple parse errors can be   reported. See Bison's simple error recovery.* Would be nice to support #if stuff.* Might want a --setting switch. Should override earlier switches and peg file settings.* Allow arbitrary sequences (instead of just strings) to be parsed?* Release checklist:	- make sure the csproj has the right version	- make sure sln still builds	